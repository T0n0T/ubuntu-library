pgsql实现增量备份主要采用的是wal文件日志，属于物理备份，可以做到热备份，具体内容如下
1. 设置 WAL 归档  
2. 制作基础备份  
3. 使用低级 API 制作基本备份  
4. 使用连续的存档备份恢复  
5. 时间线  
6. 技巧和示例  

### WAL日志
> 在任何时候，PostgreSQL都会在集群数据目录的`pg_wal`目录中保留写入日志（WAL）
> 该日志记录对数据库数据文件所做的每一个变更。
> 这个日志主要是为了安全性：如果系统崩溃，可以通过“重新放置”（即复制）自上次检查点以来的日志条目来恢复数据库的一致性。

于是，可以将文件系统级备份与WAL文件的备份结合起来。
如果需要恢复，可以恢复文件系统备份，然后从备份的WAL文件中重新播放以使系统恢复到当前状态。带来的好处是：
- **不需要一个完全一致的文件系统备份作为起点**
任何备份中的内部不一致性都将通过日志重放来纠正（这与崩溃恢复时发生的情况并无二致）。因此，我们不需要文件系统快照，<font color="#c300ff">只需要tar</font>或类似的归档工具即可。
- **可以结合无限长度的WAL文件进行重播**
对于大型数据库而言，这是非常有价值的，因为每隔一段时间就需要<font color="#c300ff">进行完整备份可能并不方便</font>。
- **无需将WAL条目重完整重播**
可以在任何时候停止重放，并使得服务器群拥有<font color="#c300ff">一致的数据库快照</font>
- **可以将数据库恢复到自备份开始以来的任何时间**
如果将连续的WAL文件序列不断发送到另一台已加载相同基础备份文件的计算机，就拥有了一个<font color="#c300ff">暖备机</font>：我们可以在任何时候启动第二台电脑，它将拥有几乎最新的数据库副本

> 与普通文件系统备份技术一样，WAL日志增量备份只支持整个数据库集群，而不是子集。
> 此外，它需要大量的存档存储：基本备份可能很笨重，而繁忙的系统将产生大量的WAL流量，这些流量必须存档。
> 然而，在许多需要高可靠性的情况下，它仍然是<font color="#c300ff">首选备份技术</font>。

### 设置 WAL 归档
正在运行的PostgreSQL系统会产生无限长的WAL记录序列。
系统会将这些序列物理地分割成WAL段文件，一般每个段文件的大小为16MB（尽管段文件的大小可以在initdb时更改）。
段文件拥有反映其在抽象WAL序列中位置的数字名称。当不使用WAL归档时，系统通常会创建一些段文件，然后通过将不再需要的段文件重新命名使其具有更高的段号来<font color="#c300ff">回收</font>它们。假定在最后一次检查点之前的段文件的内容不再有用，并可以回收。

当归档WAL数据时，可以使用许多不同的方法来将其保存：
- 复制到另一台机器上挂载的NFS目录中，将其写入磁带驱动器（确保您有一种方法来标识每个文件的原始名称），
- 批处理到一起并将其烧录到CD上，或者其他
- PostgreSQL允许管理员指定要用于复制完成段文件到其需要去的任何地方的shell命令或归档库。这可以是一个使用cp的shell命令，也可以是一个复杂的C函数

> 为了启用WAL归档，在`postgresql.conf`
> wal_level配置参数设置为<font color="#c300ff">replica或者logical</font>
> archive_mode设置为<font color="#c300ff">on</font>
> archive_command配置参数中<font color="#c300ff">指定shell命令</font>，并可以在archive_library配置参数中<font color="#c300ff">指定要使用的库</font>，库需要是c库

其中 archive_command 指定的shell命令可以如下所示，命令执行的用户是pgsql的运行账户
- `%p`为存档文件路径
- `%f`为存档文件名称
```shell
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  # Unix
```

***注意：***
- 如果包含pg_wal/的文件系统填满，PostgreSQL将执行PANIC关机。这不会丢失任何已提交的事务，但是数据库将保持离线状态，直到释放空间
- 不会恢复对配置文件（即postgresql.conf，pg_hba.conf和pg_ident.conf）所做的更改，因为这些文件是通过手动编辑的而不是sql操作，如果需要将这类配置文件与数据文件区分放置，请阅读[[pgsql配置位置]]

### pg_basebackup
保存一个基线备份的好方法
或者采用：
```sql
SELECT pg_backup_start(label => 'label', fast => false);
# 创建检查点
//...
SELECT * FROM pg_backup_stop(wait_for_archive => true);
```

### 步骤
1. 停止服务器

2. 如果有足够的空间，请将整个集群数据目录和任何表空间复制到临时位置，以备将来需要。请注意，这种预防措施将要求您的系统有足够的空闲空间来容纳现有数据库的两个副本。如果没有足够的空间，至少应该保存集群的 pg_wal 子目录的内容，因为在<font color="#c300ff">系统关闭之前可能会包含未归档</font>的日志

3. 删除集群数据目录下和正在使用的任何表空间根目录下所有现有文件和子目录

4. 从文件系统备份中恢复数据库文件。确保以正确的所有者（数据库系统用户，而不是root！）和正确的权限恢复它们。如果使用表空间，应该验证 pg_tblspc / 中的符号链接是否正确恢复

5. 删除 pg_wal/ 。这些文件来自文件系统备份，因此可能是过时的，而不是当前的文件。如果没有归档 pg_wal/，则需要以正确的权限创建它

6. 如果有在步骤2中保存的未归档 WAL 段文件，将它们复制到 pg_wal/ 中 （最好是复制它们，而不是移动它们，以便如果发生问题并且你不得不重新开始，你还有未修改过的文件）

7. 在 postgresql.conf 中设置恢复配置设置，并在集群数据目录中<font color="#c300ff">创建一个文件 recovery.signal</font>

8. 启动服务器。服务器将进入恢复模式并继续读取所需的已归档WAL文件。如果因外部错误而终止恢复，可以简单地重新启动服务器，它将继续恢复。完成恢复过程后，服务器将<font color="#c300ff">自动删除 recovery.signal</font>（以防止稍后意外重新进入恢复模式），然后开始正常的数据库操作

9. 检查数据库的内容，以确保已经恢复到所需的状态